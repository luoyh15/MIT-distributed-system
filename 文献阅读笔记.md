# MapReduce
著名的分布式系统实现方式MapReduce
## 用户层面
只需编写map和reduce函数就可以实现功能，无需关注底层分布式系统的具体实现方式。
- map函数：将数据进行本地处理
- reduce函数：涉及所有数据参与的处理，排序、计数等

## 内部实现

### 具体流程
1. 将输入文件划分成M份，存储在集群中。同时也需要将程序代码复制到所有机器中。map输出的中间结果按key重新划分为R份进行reduce。
2. 其中一份程序代码是特殊的master。其他称为workers，负责执行master分配的任务。有M个map任务和R个reduce任务需要执行。
3. worker完成map任务后将中间结果保存在本地，并将文件路径返回给master
4. master将中间结果的路径发送给需要进行reduce任务的worker，进行reduce任务的worker读取完所有中间结果后进行reduce任务，生成输出文件。
5. 所有map和reduce任务完成后，master唤醒用户程序。通常生成的R份输出文件不需要进行合并，可以直接作为下一个MapReduce的输入文件。

### 容错机制

#### worker宕机
- master会定时和每个worker通信，来检查worker是否正常。
- 如果发现某个worker通信失败，那么任何这个worker已经完成的map任务都被标记为待完成状态；且任何正在执行的map和reduce任务也被标记为待完成状态。
- map中间结果是存在本地的，只有一份，而reduce的结果已经有了备份，所以已完成的reduce任务无需重新执行。
- 任何重新执行的map任务会通知所有的reduce任务，需要读取宕机的worker中map结果的reduce任务都需要改变读取路径。

#### master宕机
- master会定期保存checkpoints。如果宕机会重新从最新的checkpoints启动。

### 任务划分粒度
- 通常以一个map任务的输入文件大小为16MB-64MB来确定M的数量，R通常是机器数量的几倍。
- M尽量更大或者说一台机器运行尽可能多的任务的好处是如果这台机器宕机，可以有更多的任务被分配到其他所有机器。

### 任务备用
- 如果某台机器运行速度变得非常慢，那么后续任务需要等待很长时间才能开始执行。解决方法是在MapReduce操作接近完成时，将剩下未完成的任务进行复制分配给其他机器执行，一旦某个机器率先完成这个任务，那么就选取最先完成的结果作为最终结果。

### 其他可以优化的点
1. 划分函数
   - 默认是直接通过hash函数
   - 如有特定需求可以定制划分函数，实现特定文件划分在同一区域的效果。
2. 保证顺序
   - 同一分区内按键值升序
3. combiner函数
   - 同一分区内可能会产生许多相同的键，对于只涉及相同键操作的reduce任务，比如统计键出现的次数，可以用combiner函数。
   - combiner相当于在本地先进行的reduce操作，得到中间结果再传输到真正的reduce任务中。减少了中间传输的数据量，也大大加速了reduce任务。
4. 文件格式
   - 默认是文本型数据
   - 可以通过reader接口匹配不同的格式
5. 副作用？
   - 原子性和幂等性
   - 没有提供两阶段提交的原子操作
6. 跳过坏数据
   - 如果程序上不能保证过滤坏数据，可以让系统自动过滤。如果发现同一数据上超过一次的出错，系统会标记该数据为坏数据并过滤。
7. 本地执行
   - 调试过程中可以启动本地模式，使得MapReduce只在本地执行。
8. 状态信息
   - master上会记录系统运行的所有信息